//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ex3ndr/Develop/actor-model/actor-ios/build/java/org/bouncycastle/util/encoders/Base64Encoder.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/IOException.h"
#include "java/io/OutputStream.h"
#include "org/bouncycastle/util/encoders/Base64Encoder.h"

__attribute__((unused)) static jboolean OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(OrgBouncycastleUtilEncodersBase64Encoder *self, jchar c);
__attribute__((unused)) static jint OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(OrgBouncycastleUtilEncodersBase64Encoder *self, IOSByteArray *data, jint i, jint finish);
__attribute__((unused)) static jint OrgBouncycastleUtilEncodersBase64Encoder_decodeLastBlockWithJavaIoOutputStream_withChar_withChar_withChar_withChar_(OrgBouncycastleUtilEncodersBase64Encoder *self, JavaIoOutputStream *outArg, jchar c1, jchar c2, jchar c3, jchar c4);
__attribute__((unused)) static jint OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(OrgBouncycastleUtilEncodersBase64Encoder *self, NSString *data, jint i, jint finish);

@interface OrgBouncycastleUtilEncodersBase64Encoder ()

- (jboolean)ignoreWithChar:(jchar)c;

- (jint)nextIWithByteArray:(IOSByteArray *)data
                   withInt:(jint)i
                   withInt:(jint)finish;

- (jint)decodeLastBlockWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                                     withChar:(jchar)c1
                                     withChar:(jchar)c2
                                     withChar:(jchar)c3
                                     withChar:(jchar)c4;

- (jint)nextIWithNSString:(NSString *)data
                  withInt:(jint)i
                  withInt:(jint)finish;
@end

@implementation OrgBouncycastleUtilEncodersBase64Encoder

- (void)initialiseDecodingTable {
  for (jint i = 0; i < ((IOSByteArray *) nil_chk(decodingTable_))->size_; i++) {
    *IOSByteArray_GetRef(decodingTable_, i) = (jbyte) (jint) 0xff;
  }
  for (jint i = 0; i < ((IOSByteArray *) nil_chk(encodingTable_))->size_; i++) {
    *IOSByteArray_GetRef(decodingTable_, IOSByteArray_Get(encodingTable_, i)) = (jbyte) i;
  }
}

- (instancetype)init {
  if (self = [super init]) {
    encodingTable_ = [IOSByteArray newArrayWithBytes:(jbyte[]){ (jbyte) 'A', (jbyte) 'B', (jbyte) 'C', (jbyte) 'D', (jbyte) 'E', (jbyte) 'F', (jbyte) 'G', (jbyte) 'H', (jbyte) 'I', (jbyte) 'J', (jbyte) 'K', (jbyte) 'L', (jbyte) 'M', (jbyte) 'N', (jbyte) 'O', (jbyte) 'P', (jbyte) 'Q', (jbyte) 'R', (jbyte) 'S', (jbyte) 'T', (jbyte) 'U', (jbyte) 'V', (jbyte) 'W', (jbyte) 'X', (jbyte) 'Y', (jbyte) 'Z', (jbyte) 'a', (jbyte) 'b', (jbyte) 'c', (jbyte) 'd', (jbyte) 'e', (jbyte) 'f', (jbyte) 'g', (jbyte) 'h', (jbyte) 'i', (jbyte) 'j', (jbyte) 'k', (jbyte) 'l', (jbyte) 'm', (jbyte) 'n', (jbyte) 'o', (jbyte) 'p', (jbyte) 'q', (jbyte) 'r', (jbyte) 's', (jbyte) 't', (jbyte) 'u', (jbyte) 'v', (jbyte) 'w', (jbyte) 'x', (jbyte) 'y', (jbyte) 'z', (jbyte) '0', (jbyte) '1', (jbyte) '2', (jbyte) '3', (jbyte) '4', (jbyte) '5', (jbyte) '6', (jbyte) '7', (jbyte) '8', (jbyte) '9', (jbyte) '+', (jbyte) '/' } count:64];
    padding_ = (jbyte) '=';
    decodingTable_ = [IOSByteArray newArrayWithLength:128];
    [self initialiseDecodingTable];
  }
  return self;
}

- (jint)encodeWithByteArray:(IOSByteArray *)data
                    withInt:(jint)off
                    withInt:(jint)length
     withJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  jint modulus = length % 3;
  jint dataLength = (length - modulus);
  jint a1, a2, a3;
  for (jint i = off; i < off + dataLength; i += 3) {
    a1 = IOSByteArray_Get(nil_chk(data), i) & (jint) 0xff;
    a2 = IOSByteArray_Get(data, i + 1) & (jint) 0xff;
    a3 = IOSByteArray_Get(data, i + 2) & (jint) 0xff;
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:IOSByteArray_Get(nil_chk(encodingTable_), (URShift32(a1, 2)) & (jint) 0x3f)];
    [outArg writeWithInt:IOSByteArray_Get(encodingTable_, ((LShift32(a1, 4)) | (URShift32(a2, 4))) & (jint) 0x3f)];
    [outArg writeWithInt:IOSByteArray_Get(encodingTable_, ((LShift32(a2, 2)) | (URShift32(a3, 6))) & (jint) 0x3f)];
    [outArg writeWithInt:IOSByteArray_Get(encodingTable_, a3 & (jint) 0x3f)];
  }
  jint b1, b2, b3;
  jint d1, d2;
  switch (modulus) {
    case 0:
    break;
    case 1:
    d1 = IOSByteArray_Get(nil_chk(data), off + dataLength) & (jint) 0xff;
    b1 = (URShift32(d1, 2)) & (jint) 0x3f;
    b2 = (LShift32(d1, 4)) & (jint) 0x3f;
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:IOSByteArray_Get(nil_chk(encodingTable_), b1)];
    [outArg writeWithInt:IOSByteArray_Get(encodingTable_, b2)];
    [outArg writeWithInt:padding_];
    [outArg writeWithInt:padding_];
    break;
    case 2:
    d1 = IOSByteArray_Get(nil_chk(data), off + dataLength) & (jint) 0xff;
    d2 = IOSByteArray_Get(data, off + dataLength + 1) & (jint) 0xff;
    b1 = (URShift32(d1, 2)) & (jint) 0x3f;
    b2 = ((LShift32(d1, 4)) | (URShift32(d2, 4))) & (jint) 0x3f;
    b3 = (LShift32(d2, 2)) & (jint) 0x3f;
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:IOSByteArray_Get(nil_chk(encodingTable_), b1)];
    [outArg writeWithInt:IOSByteArray_Get(encodingTable_, b2)];
    [outArg writeWithInt:IOSByteArray_Get(encodingTable_, b3)];
    [outArg writeWithInt:padding_];
    break;
  }
  return (dataLength / 3) * 4 + ((modulus == 0) ? 0 : 4);
}

- (jboolean)ignoreWithChar:(jchar)c {
  return OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(self, c);
}

- (jint)decodeWithByteArray:(IOSByteArray *)data
                    withInt:(jint)off
                    withInt:(jint)length
     withJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  jbyte b1, b2, b3, b4;
  jint outLen = 0;
  jint end = off + length;
  while (end > off) {
    if (!OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(self, (jchar) IOSByteArray_Get(nil_chk(data), end - 1))) {
      break;
    }
    end--;
  }
  jint i = off;
  jint finish = end - 4;
  i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, i, finish);
  while (i < finish) {
    b1 = IOSByteArray_Get(nil_chk(decodingTable_), IOSByteArray_Get(nil_chk(data), i++));
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, i, finish);
    b2 = IOSByteArray_Get(decodingTable_, IOSByteArray_Get(data, i++));
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, i, finish);
    b3 = IOSByteArray_Get(decodingTable_, IOSByteArray_Get(data, i++));
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, i, finish);
    b4 = IOSByteArray_Get(decodingTable_, IOSByteArray_Get(data, i++));
    if ((b1 | b2 | b3 | b4) < 0) {
      @throw [[JavaIoIOException alloc] initWithNSString:@"invalid characters encountered in base64 data"];
    }
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:(LShift32(b1, 2)) | (RShift32(b2, 4))];
    [outArg writeWithInt:(LShift32(b2, 4)) | (RShift32(b3, 2))];
    [outArg writeWithInt:(LShift32(b3, 6)) | b4];
    outLen += 3;
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, i, finish);
  }
  outLen += OrgBouncycastleUtilEncodersBase64Encoder_decodeLastBlockWithJavaIoOutputStream_withChar_withChar_withChar_withChar_(self, outArg, (jchar) IOSByteArray_Get(nil_chk(data), end - 4), (jchar) IOSByteArray_Get(data, end - 3), (jchar) IOSByteArray_Get(data, end - 2), (jchar) IOSByteArray_Get(data, end - 1));
  return outLen;
}

- (jint)nextIWithByteArray:(IOSByteArray *)data
                   withInt:(jint)i
                   withInt:(jint)finish {
  return OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, i, finish);
}

- (jint)decodeWithNSString:(NSString *)data
    withJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  jbyte b1, b2, b3, b4;
  jint length = 0;
  jint end = ((jint) [((NSString *) nil_chk(data)) length]);
  while (end > 0) {
    if (!OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(self, [data charAtWithInt:end - 1])) {
      break;
    }
    end--;
  }
  jint i = 0;
  jint finish = end - 4;
  i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, i, finish);
  while (i < finish) {
    b1 = IOSByteArray_Get(nil_chk(decodingTable_), [data charAtWithInt:i++]);
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, i, finish);
    b2 = IOSByteArray_Get(decodingTable_, [data charAtWithInt:i++]);
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, i, finish);
    b3 = IOSByteArray_Get(decodingTable_, [data charAtWithInt:i++]);
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, i, finish);
    b4 = IOSByteArray_Get(decodingTable_, [data charAtWithInt:i++]);
    if ((b1 | b2 | b3 | b4) < 0) {
      @throw [[JavaIoIOException alloc] initWithNSString:@"invalid characters encountered in base64 data"];
    }
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:(LShift32(b1, 2)) | (RShift32(b2, 4))];
    [outArg writeWithInt:(LShift32(b2, 4)) | (RShift32(b3, 2))];
    [outArg writeWithInt:(LShift32(b3, 6)) | b4];
    length += 3;
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, i, finish);
  }
  length += OrgBouncycastleUtilEncodersBase64Encoder_decodeLastBlockWithJavaIoOutputStream_withChar_withChar_withChar_withChar_(self, outArg, [data charAtWithInt:end - 4], [data charAtWithInt:end - 3], [data charAtWithInt:end - 2], [data charAtWithInt:end - 1]);
  return length;
}

- (jint)decodeLastBlockWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                                     withChar:(jchar)c1
                                     withChar:(jchar)c2
                                     withChar:(jchar)c3
                                     withChar:(jchar)c4 {
  return OrgBouncycastleUtilEncodersBase64Encoder_decodeLastBlockWithJavaIoOutputStream_withChar_withChar_withChar_withChar_(self, outArg, c1, c2, c3, c4);
}

- (jint)nextIWithNSString:(NSString *)data
                  withInt:(jint)i
                  withInt:(jint)finish {
  return OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, i, finish);
}

- (void)copyAllFieldsTo:(OrgBouncycastleUtilEncodersBase64Encoder *)other {
  [super copyAllFieldsTo:other];
  other->encodingTable_ = encodingTable_;
  other->padding_ = padding_;
  other->decodingTable_ = decodingTable_;
}

@end

jboolean OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(OrgBouncycastleUtilEncodersBase64Encoder *self, jchar c) {
  return (c == 0x000a || c == 0x000d || c == 0x0009 || c == ' ');
}

jint OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(OrgBouncycastleUtilEncodersBase64Encoder *self, IOSByteArray *data, jint i, jint finish) {
  while ((i < finish) && OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(self, (jchar) IOSByteArray_Get(nil_chk(data), i))) {
    i++;
  }
  return i;
}

jint OrgBouncycastleUtilEncodersBase64Encoder_decodeLastBlockWithJavaIoOutputStream_withChar_withChar_withChar_withChar_(OrgBouncycastleUtilEncodersBase64Encoder *self, JavaIoOutputStream *outArg, jchar c1, jchar c2, jchar c3, jchar c4) {
  jbyte b1, b2, b3, b4;
  if (c3 == self->padding_) {
    b1 = IOSByteArray_Get(nil_chk(self->decodingTable_), c1);
    b2 = IOSByteArray_Get(self->decodingTable_, c2);
    if ((b1 | b2) < 0) {
      @throw [[JavaIoIOException alloc] initWithNSString:@"invalid characters encountered at end of base64 data"];
    }
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:(LShift32(b1, 2)) | (RShift32(b2, 4))];
    return 1;
  }
  else if (c4 == self->padding_) {
    b1 = IOSByteArray_Get(nil_chk(self->decodingTable_), c1);
    b2 = IOSByteArray_Get(self->decodingTable_, c2);
    b3 = IOSByteArray_Get(self->decodingTable_, c3);
    if ((b1 | b2 | b3) < 0) {
      @throw [[JavaIoIOException alloc] initWithNSString:@"invalid characters encountered at end of base64 data"];
    }
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:(LShift32(b1, 2)) | (RShift32(b2, 4))];
    [outArg writeWithInt:(LShift32(b2, 4)) | (RShift32(b3, 2))];
    return 2;
  }
  else {
    b1 = IOSByteArray_Get(nil_chk(self->decodingTable_), c1);
    b2 = IOSByteArray_Get(self->decodingTable_, c2);
    b3 = IOSByteArray_Get(self->decodingTable_, c3);
    b4 = IOSByteArray_Get(self->decodingTable_, c4);
    if ((b1 | b2 | b3 | b4) < 0) {
      @throw [[JavaIoIOException alloc] initWithNSString:@"invalid characters encountered at end of base64 data"];
    }
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:(LShift32(b1, 2)) | (RShift32(b2, 4))];
    [outArg writeWithInt:(LShift32(b2, 4)) | (RShift32(b3, 2))];
    [outArg writeWithInt:(LShift32(b3, 6)) | b4];
    return 3;
  }
}

jint OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(OrgBouncycastleUtilEncodersBase64Encoder *self, NSString *data, jint i, jint finish) {
  while ((i < finish) && OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(self, [((NSString *) nil_chk(data)) charAtWithInt:i])) {
    i++;
  }
  return i;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgBouncycastleUtilEncodersBase64Encoder)
