//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ex3ndr/Develop/actor-model/actor-ios/build/java/org/bouncycastle/util/encoders/HexEncoder.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/IOException.h"
#include "java/io/OutputStream.h"
#include "org/bouncycastle/util/encoders/HexEncoder.h"

__attribute__((unused)) static jboolean OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_(jchar c);

@interface OrgBouncycastleUtilEncodersHexEncoder ()

+ (jboolean)ignoreWithChar:(jchar)c;
@end

@implementation OrgBouncycastleUtilEncodersHexEncoder

- (void)initialiseDecodingTable {
  for (jint i = 0; i < ((IOSByteArray *) nil_chk(decodingTable_))->size_; i++) {
    *IOSByteArray_GetRef(decodingTable_, i) = (jbyte) (jint) 0xff;
  }
  for (jint i = 0; i < ((IOSByteArray *) nil_chk(encodingTable_))->size_; i++) {
    *IOSByteArray_GetRef(decodingTable_, IOSByteArray_Get(encodingTable_, i)) = (jbyte) i;
  }
  *IOSByteArray_GetRef(decodingTable_, 'A') = IOSByteArray_Get(decodingTable_, 'a');
  *IOSByteArray_GetRef(decodingTable_, 'B') = IOSByteArray_Get(decodingTable_, 'b');
  *IOSByteArray_GetRef(decodingTable_, 'C') = IOSByteArray_Get(decodingTable_, 'c');
  *IOSByteArray_GetRef(decodingTable_, 'D') = IOSByteArray_Get(decodingTable_, 'd');
  *IOSByteArray_GetRef(decodingTable_, 'E') = IOSByteArray_Get(decodingTable_, 'e');
  *IOSByteArray_GetRef(decodingTable_, 'F') = IOSByteArray_Get(decodingTable_, 'f');
}

- (instancetype)init {
  if (self = [super init]) {
    encodingTable_ = [IOSByteArray newArrayWithBytes:(jbyte[]){ (jbyte) '0', (jbyte) '1', (jbyte) '2', (jbyte) '3', (jbyte) '4', (jbyte) '5', (jbyte) '6', (jbyte) '7', (jbyte) '8', (jbyte) '9', (jbyte) 'a', (jbyte) 'b', (jbyte) 'c', (jbyte) 'd', (jbyte) 'e', (jbyte) 'f' } count:16];
    decodingTable_ = [IOSByteArray newArrayWithLength:128];
    [self initialiseDecodingTable];
  }
  return self;
}

- (jint)encodeWithByteArray:(IOSByteArray *)data
                    withInt:(jint)off
                    withInt:(jint)length
     withJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  for (jint i = off; i < (off + length); i++) {
    jint v = IOSByteArray_Get(nil_chk(data), i) & (jint) 0xff;
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:IOSByteArray_Get(nil_chk(encodingTable_), (URShift32(v, 4)))];
    [outArg writeWithInt:IOSByteArray_Get(encodingTable_, v & (jint) 0xf)];
  }
  return length * 2;
}

+ (jboolean)ignoreWithChar:(jchar)c {
  return OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_(c);
}

- (jint)decodeWithByteArray:(IOSByteArray *)data
                    withInt:(jint)off
                    withInt:(jint)length
     withJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  jbyte b1, b2;
  jint outLen = 0;
  jint end = off + length;
  while (end > off) {
    if (!OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_((jchar) IOSByteArray_Get(nil_chk(data), end - 1))) {
      break;
    }
    end--;
  }
  jint i = off;
  while (i < end) {
    while (i < end && OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_((jchar) IOSByteArray_Get(nil_chk(data), i))) {
      i++;
    }
    b1 = IOSByteArray_Get(nil_chk(decodingTable_), IOSByteArray_Get(nil_chk(data), i++));
    while (i < end && OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_((jchar) IOSByteArray_Get(data, i))) {
      i++;
    }
    b2 = IOSByteArray_Get(decodingTable_, IOSByteArray_Get(data, i++));
    if ((b1 | b2) < 0) {
      @throw [[JavaIoIOException alloc] initWithNSString:@"invalid characters encountered in Hex data"];
    }
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:(LShift32(b1, 4)) | b2];
    outLen++;
  }
  return outLen;
}

- (jint)decodeWithNSString:(NSString *)data
    withJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  jbyte b1, b2;
  jint length = 0;
  jint end = ((jint) [((NSString *) nil_chk(data)) length]);
  while (end > 0) {
    if (!OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_([data charAtWithInt:end - 1])) {
      break;
    }
    end--;
  }
  jint i = 0;
  while (i < end) {
    while (i < end && OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_([data charAtWithInt:i])) {
      i++;
    }
    b1 = IOSByteArray_Get(nil_chk(decodingTable_), [data charAtWithInt:i++]);
    while (i < end && OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_([data charAtWithInt:i])) {
      i++;
    }
    b2 = IOSByteArray_Get(decodingTable_, [data charAtWithInt:i++]);
    if ((b1 | b2) < 0) {
      @throw [[JavaIoIOException alloc] initWithNSString:@"invalid characters encountered in Hex string"];
    }
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:(LShift32(b1, 4)) | b2];
    length++;
  }
  return length;
}

- (void)copyAllFieldsTo:(OrgBouncycastleUtilEncodersHexEncoder *)other {
  [super copyAllFieldsTo:other];
  other->encodingTable_ = encodingTable_;
  other->decodingTable_ = decodingTable_;
}

@end

jboolean OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_(jchar c) {
  OrgBouncycastleUtilEncodersHexEncoder_init();
  return c == 0x000a || c == 0x000d || c == 0x0009 || c == ' ';
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgBouncycastleUtilEncodersHexEncoder)
